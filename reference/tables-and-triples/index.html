<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Tables and Triples - OBO Semantic Engineering Training</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Tables and Triples";
    var mkdocs_page_input_path = "reference/tables-and-triples.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> OBO Semantic Engineering Training</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../..">About the course</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../getting_started/">Getting started with learning</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../overview/">Overview of lessons and tutorials</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../contributing/">Contribe to the course</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Lessons</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../lesson/contributing_to_obo_ontologies/">Contributing to OBO ontologies</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../lesson/ontology_pipelines/">Ontology Pipelines with ROBOT</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Courses</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../tutorial/icbo2021/">ICBO 2021 Tutorial</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../courses/monarch-obo-training/">Monarch Ontology Training</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Tutorials</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../tutorial/robot_tutorial_1/">ROBOT Mini-Tutorial 1 - Convert, Extract and Template</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../tutorial/robot_tutorial_2/">ROBOT Mini-Tutorial 2 - Annotate, Merge, Reason and Diff</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../tutorial/robot_tutorial_qc/">ROBOT Mini-Tutorial QC - Quality Control with report and query</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">How-to guides</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../howto/installing_elk_in_protege/">Installing ELK in Protege</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../howto/odk_setup/">Setting up the ODK</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../howto/clone_mondo_repo/">Clone the Mondo ontology repository</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../howto/github_create_fork/">Creating an GitHub Fork</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../howto/github_create_pull_request/">Creating an GitHub Pull Request</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">OBO Semantic Engineering Training</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
    
    <li>Tables and Triples</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h1 id="tables-and-triples">Tables and Triples<a class="headerlink" href="#tables-and-triples" title="Permanent link">&para;</a></h1>
<p>Tables and triples seem very different.
Tables are familiar and predictable.
Triples are weird and floppy.
SQL is normal, SPARQL is bizarre, at least at first.</p>
<p>Tables are great, and they're the right tool for a lot of jobs,
but they have their limitations.
Triples shine when it comes to merging heterogeneous data.
But it turns out that there's a clear path from tables to triples,
which should help make RDF make more sense.</p>
<h2 id="tables">Tables<a class="headerlink" href="#tables" title="Permanent link">&para;</a></h2>
<p>Tables are great!
Here's a table!</p>
<table>
<thead>
<tr>
<th>first_name</th>
<th>last_name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Luke</td>
<td>Skywalker</td>
</tr>
<tr>
<td>Leia</td>
<td>Organa</td>
</tr>
<tr>
<td>Darth</td>
<td>Vader</td>
</tr>
<tr>
<td>Han</td>
<td>Solo</td>
</tr>
</tbody>
</table>
<p>You won't be surprised to find out
that tables have <em>rows</em> and <em>columns</em>.
Often each row corresponds to some thing
that we want to talk about,
such as a fictional character from <em>Star Wars</em>.
Each column usually corresponds to some sort of property
that those things might have.
Then the cells contain the values of those properties
for their respective row.
We take some sort of complex information about the world,
and we break it down along two dimensions:
the things (rows) and their properties (columns).</p>
<h2 id="primary-keys">Primary Keys<a class="headerlink" href="#primary-keys" title="Permanent link">&para;</a></h2>
<p>Tables are great!
We can add another name to our table:</p>
<table>
<thead>
<tr>
<th>first_name</th>
<th>last_name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Luke</td>
<td>Skywalker</td>
</tr>
<tr>
<td>Leia</td>
<td>Organa</td>
</tr>
<tr>
<td>Darth</td>
<td>Vader</td>
</tr>
<tr>
<td>Han</td>
<td>Solo</td>
</tr>
<tr>
<td>Anakin</td>
<td>Skywalker</td>
</tr>
</tbody>
</table>
<p>Hmm.
That's a perfectly good table,
but it's not capturing the information that we wanted.
It turns out (<strong>Spoiler Alert!</strong>) that Anakin Skywalker <em>is</em> Darth Vader!
We might have thought that the rows of our table
were describing individual people,
but it turns out that they're just describing individual names.
A person can change their name
or have more than one name.</p>
<p>We want some sort of identifier
that lets us pick out the same person,
and distinguish them from all the other people.
Sometimes there's a "natural key" that we can use for this purpose:
some bit of information that uniquely identifies a thing.
When we don't have a natural key, we can generate an "artificial key".
Random strings and number can be good artificial keys,
but sometimes a simple incrementing integer is good enough.</p>
<p>The main problem with artificial keys
is that it's our job to <em>maintain the link</em>
between the thing and the identifier that we gave it.
We prefer natural keys because we just have to inspect that thing
(in some way)
to figure out what to call it.
Even when it's possible,
sometimes that's too much work.
Maybe we could use a DNA sequence as a natural key for a person,
but it probably isn't practical.
We do use fingerprints and facial recognition,
for similar things, though.</p>
<p>(Do people in <em>Star Wars</em> even have DNA?
Or just midichlorions?)</p>
<p>Let's add a column with an artificial key to our table:</p>
<table>
<thead>
<tr>
<th>sw_id</th>
<th>first_name</th>
<th>last_name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Luke</td>
<td>Skywalker</td>
</tr>
<tr>
<td>2</td>
<td>Leia</td>
<td>Organa</td>
</tr>
<tr>
<td>3</td>
<td>Darth</td>
<td>Vader</td>
</tr>
<tr>
<td>4</td>
<td>Han</td>
<td>Solo</td>
</tr>
<tr>
<td>3</td>
<td>Anakin</td>
<td>Skywalker</td>
</tr>
</tbody>
</table>
<p>This is our table of names,
allowing a given person to have multiple names.
But what we <em>thought</em> we wanted was a person table
with one row for each person, like this:</p>
<table>
<thead>
<tr>
<th>sw_id</th>
<th>first_name</th>
<th>last_name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Luke</td>
<td>Skywalker</td>
</tr>
<tr>
<td>2</td>
<td>Leia</td>
<td>Organa</td>
</tr>
<tr>
<td>3</td>
<td>Darth</td>
<td>Vader</td>
</tr>
<tr>
<td>4</td>
<td>Han</td>
<td>Solo</td>
</tr>
</tbody>
</table>
<p>In SQL we could assert that the "sw_id" column of the person table
is a PRIMARY KEY.
This means it must be unique.
(It probably shouldn't be NULL either!)</p>
<p>The names in the person table could be the primary names
that we use in our <em>Star Wars</em> database system,
and we could have another alternative_name table:</p>
<table>
<thead>
<tr>
<th>sw_id</th>
<th>first_name</th>
<th>last_name</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>Anakin</td>
<td>Skywalker</td>
</tr>
</tbody>
</table>
<h2 id="holes">Holes<a class="headerlink" href="#holes" title="Permanent link">&para;</a></h2>
<p>Tables are great!
We can add more columns to our person table:</p>
<table>
<thead>
<tr>
<th>sw_id</th>
<th>first_name</th>
<th>last_name</th>
<th>occupation</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Luke</td>
<td>Skywalker</td>
<td>Jedi</td>
</tr>
<tr>
<td>2</td>
<td>Leia</td>
<td>Organa</td>
<td>princess</td>
</tr>
<tr>
<td>3</td>
<td>Darth</td>
<td>Vader</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>Han</td>
<td>Solo</td>
<td>scoundrel</td>
</tr>
</tbody>
</table>
<p>The 2D pattern of a table is a strong one.
It not only provides a "slot" (cell)
for every combination of row and column,
it also makes it very obvious when one of those slots is <em>empty</em>.
What does it mean for a slot to be empty?
It could mean many things.</p>
<p>For example, in the previous table
in the row for Darth Vader,
the cell for the "occupation" column is empty.
This could mean that:</p>
<ul>
<li>we don't know whether he has an occupation</li>
<li>we know that he has an occupation, but we don't know which occupation it is.</li>
<li>we might know, but we haven't bothered to write it down yet</li>
<li>we might know, but it doesn't fit nicely
  into the New Republic Standard Registry of Occupations;
  in other words, we know what his occupation is,
  but including it here would violate a constraint on our database</li>
<li>we specifically know that he doesn't have an occupation;
  we triple-checked</li>
<li>we know more generally (<strong>Spoiler Alert!!</strong>) that he's dead,
  and dead people can't have an occupation.</li>
</ul>
<p>I'm sure I haven't captured all the possibilities.
The point is that there's lot of possible reasons
why a cell would be blank.
So what can we do about it?</p>
<p>If our table is stored in a SQL database,
then we have the option of putting a NULL value in the cell.
NULL is pretty strange.
It isn't TRUE and it isn't FALSE.
Usually NULL values are excluded from SQL query results
unless you are careful to ask for them.</p>
<p>The way that NULL works in SQL eliminates some of the possibilities above.
SQL uses the "closed-world assumption",
which is the assumption that if a statement is true then it's known to be true,
and conversely that if it's not known to be true then it's false.
So if Anakin's occupation is NULL in a SQL database,
then as far as SQL is concerned,
we must know that he doesn't have an occupation.
That might not be what you were expecting!</p>
<p>The Software Carpentry module on
<a href="http://swcarpentry.github.io/sql-novice-survey/05-null/index.html">Missing Data</a>
has more information.</p>
<h2 id="multiple-values">Multiple Values<a class="headerlink" href="#multiple-values" title="Permanent link">&para;</a></h2>
<p>Tables are great!
Let's add even more information to our table:</p>
<table>
<thead>
<tr>
<th>sw_id</th>
<th>first_name</th>
<th>last_name</th>
<th>occupation</th>
<th>enemy</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Luke</td>
<td>Skywalker</td>
<td>Jedi</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>Leia</td>
<td>Organa</td>
<td>princess</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>Darth</td>
<td>Vader</td>
<td></td>
<td>1,2,4</td>
</tr>
<tr>
<td>4</td>
<td>Han</td>
<td>Solo</td>
<td>scoundrel</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>We're trying to say that Darth Vader is the enemy of everybody else in our table.
We're using the primary key of the person in the enemy column, which is good,
but we've ended up with multiple values in the "enemy" column
for Darth Vader.</p>
<p>In any table or SQL database you could
make the "enemy" column a string,
pick a delimiter such as the comma,
and concatenate your values into a comma-separated list.
This works, but not very well.</p>
<p>In some SQL databases, such as Postgres,
you could given the "enemy" column an array type,
so it can contain multiple values.
You get special operators for querying inside arrays.
This can work pretty well.</p>
<p>The usual advice is to break this "one to many" information
into a new "enemy" table:</p>
<table>
<thead>
<tr>
<th>sw_id</th>
<th>enemy</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Then you can JOIN the person table to the enemy table as needed.</p>
<h2 id="sparse-tables">Sparse Tables<a class="headerlink" href="#sparse-tables" title="Permanent link">&para;</a></h2>
<p>Tables are great!
Let's add even more information to our table:</p>
<table>
<thead>
<tr>
<th>sw_id</th>
<th>first_name</th>
<th>last_name</th>
<th>occupation</th>
<th>father</th>
<th>lightsaber_color</th>
<th>ship</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Luke</td>
<td>Skywalker</td>
<td>Jedi</td>
<td>3</td>
<td>green</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>Leia</td>
<td>Organa</td>
<td>princess</td>
<td>3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>Darth</td>
<td>Vader</td>
<td></td>
<td></td>
<td>red</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>Han</td>
<td>Solo</td>
<td>scoundrel</td>
<td></td>
<td></td>
<td>Millennium Falcon</td>
</tr>
</tbody>
</table>
<p>A bunch of these columns only apply to a few rows.
Now we've got a lot more NULLs to deal with.
As the number of columns increases,
this can become a problem.</p>
<h2 id="property-tables">Property Tables<a class="headerlink" href="#property-tables" title="Permanent link">&para;</a></h2>
<p>Tables are great!
If sparse tables are a problem,
then let's try to apply the same solution
that worked for the "many to one" problem in the previous section.</p>
<p>name table:</p>
<table>
<thead>
<tr>
<th>sw_id</th>
<th>first_name</th>
<th>last_name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Luke</td>
<td>Skywalker</td>
</tr>
<tr>
<td>2</td>
<td>Leia</td>
<td>Organa</td>
</tr>
<tr>
<td>3</td>
<td>Darth</td>
<td>Vader</td>
</tr>
<tr>
<td>4</td>
<td>Han</td>
<td>Solo</td>
</tr>
<tr>
<td>3</td>
<td>Anakin</td>
<td>Skywalker</td>
</tr>
</tbody>
</table>
<p>occupation table:</p>
<table>
<thead>
<tr>
<th>sw_id</th>
<th>occupation</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Jedi</td>
</tr>
<tr>
<td>2</td>
<td>princess</td>
</tr>
<tr>
<td>4</td>
<td>scoundrel</td>
</tr>
</tbody>
</table>
<p>enemy table:</p>
<table>
<thead>
<tr>
<th>sw_id</th>
<th>enemy</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>father table:</p>
<table>
<thead>
<tr>
<th>sw_id</th>
<th>father</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>lightsaber_color table:</p>
<table>
<thead>
<tr>
<th>sw_id</th>
<th>lightsaber_color</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>green</td>
</tr>
<tr>
<td>3</td>
<td>red</td>
</tr>
</tbody>
</table>
<p>ship table:</p>
<table>
<thead>
<tr>
<th>sw_id</th>
<th>ship</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>Millennium Falcon</td>
</tr>
</tbody>
</table>
<p>Hmm.
Yeah, that will work.
But every query we write will need some JOINs.
It feels like we've lost something.</p>
<h2 id="entity-attribute-value">Entity, Attribute, Value<a class="headerlink" href="#entity-attribute-value" title="Permanent link">&para;</a></h2>
<p>Tables are great!
But there's such a thing as <em>too many</em> tables.
We started out with a table
with a bunch of rows and a bunch of columns,
and ended up with a bunch of tables
with a bunch of rows but just a few columns.</p>
<p>I have a brilliant idea!
Let's combine all these property tables into just one table,
by adding a "property" column!</p>
<table>
<thead>
<tr>
<th>sw_id</th>
<th>property</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>first_name</td>
<td>Luke</td>
</tr>
<tr>
<td>2</td>
<td>first_name</td>
<td>Leia</td>
</tr>
<tr>
<td>3</td>
<td>first_name</td>
<td>Darth</td>
</tr>
<tr>
<td>4</td>
<td>first_name</td>
<td>Han</td>
</tr>
<tr>
<td>5</td>
<td>first_name</td>
<td>Anakin</td>
</tr>
<tr>
<td>1</td>
<td>last_name</td>
<td>Skywalker</td>
</tr>
<tr>
<td>2</td>
<td>last_name</td>
<td>Skywalker</td>
</tr>
<tr>
<td>3</td>
<td>last_name</td>
<td>Vader</td>
</tr>
<tr>
<td>4</td>
<td>last_name</td>
<td>Solo</td>
</tr>
<tr>
<td>5</td>
<td>last_name</td>
<td>Skywalker</td>
</tr>
<tr>
<td>1</td>
<td>occupation</td>
<td>Jedi</td>
</tr>
<tr>
<td>2</td>
<td>occupation</td>
<td>princess</td>
</tr>
<tr>
<td>4</td>
<td>occupation</td>
<td>scoundrel</td>
</tr>
<tr>
<td>1</td>
<td>enemy</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>enemy</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>enemy</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>enemy</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>enemy</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>enemy</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>father</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>father</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>lightsaber_color</td>
<td>green</td>
</tr>
<tr>
<td>3</td>
<td>lightsaber_color</td>
<td>red</td>
</tr>
<tr>
<td>4</td>
<td>ship</td>
<td>Millenium Falcon</td>
</tr>
</tbody>
</table>
<p>It turns out that I'm not the first one to think of this idea.
People call it "Entity, Attribute, Value" or "EAV".
People also call it an "anti-pattern",
in other words: a clear sign that you've made a terrible mistake.</p>
<p>There are lots of circumstances in which
one big, extremely generic table is a bad idea.
First of all, you can't do very much
with the datatypes for the property and value columns.
They kind of have to be strings.
It's potentially difficult to index.
And tables like this are miserable to query,
because you end up with all sorts of self-joins to handle.</p>
<p>But there's at least one use case where it turns out to work quite well...</p>
<h2 id="merging-tables">Merging Tables<a class="headerlink" href="#merging-tables" title="Permanent link">&para;</a></h2>
<p>Tables are great!
Until they're not.</p>
<p>The strong row and column structure of tables
makes them great for lots of things,
but not so great for merging data from different sources.
Before you can merge two tables
you need to know all about:</p>
<ol>
<li>how the columns are structured</li>
<li>what the rows mean</li>
<li>what the cells mean</li>
</ol>
<p>So you need to know the schemas of the two tables
before you can start merging them together.
But if you happen to have two EAV tables then,
as luck would have it,
they already have <em>the same</em> schema!</p>
<p>You also need to know that you're talking about the same things:
the rows have to be about the same things,
you need to be using the same property names for the same things,
and the cell values also need to line up.
If only there was an open standard for specifying globally unique identifiers...</p>
<p>Yes, you guessed it: URLs (and URNs and URIs and IRIs)!
Let's assume that we use the same URLs for the same things
across the two tables.
Since we're a close-knit community,
we've come to an agreement on a <em>Star Wars</em> data vocabulary.</p>
<p>URLs are annoyingly long to use in databases,
so let's use standard "sw" prefix to shorten them.
Now we have table 1:</p>
<table>
<thead>
<tr>
<th>sw_id</th>
<th>property</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>sw:1</td>
<td>sw:first_name</td>
<td>Luke</td>
</tr>
<tr>
<td>sw:2</td>
<td>sw:first_name</td>
<td>Leia</td>
</tr>
<tr>
<td>sw:3</td>
<td>sw:first_name</td>
<td>Darth</td>
</tr>
<tr>
<td>sw:4</td>
<td>sw:first_name</td>
<td>Han</td>
</tr>
<tr>
<td>sw:5</td>
<td>sw:first_name</td>
<td>Anakin</td>
</tr>
<tr>
<td>sw:1</td>
<td>sw:last_name</td>
<td>Skywalker</td>
</tr>
<tr>
<td>sw:2</td>
<td>sw:last_name</td>
<td>Skywalker</td>
</tr>
<tr>
<td>sw:3</td>
<td>sw:last_name</td>
<td>Vader</td>
</tr>
<tr>
<td>sw:4</td>
<td>sw:last_name</td>
<td>Solo</td>
</tr>
<tr>
<td>sw:5</td>
<td>sw:last_name</td>
<td>Skywalker</td>
</tr>
<tr>
<td>sw:1</td>
<td>sw:occupation</td>
<td>sw:Jedi</td>
</tr>
<tr>
<td>sw:2</td>
<td>sw:occupation</td>
<td>sw:princess</td>
</tr>
<tr>
<td>sw:4</td>
<td>sw:occupation</td>
<td>sw:scoundrel</td>
</tr>
</tbody>
</table>
<p>and table 2:</p>
<table>
<thead>
<tr>
<th>sw_id</th>
<th>property</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>sw:1</td>
<td>sw:enemy</td>
<td>sw:3</td>
</tr>
<tr>
<td>sw:2</td>
<td>sw:enemy</td>
<td>sw:3</td>
</tr>
<tr>
<td>sw:3</td>
<td>sw:enemy</td>
<td>sw:1</td>
</tr>
<tr>
<td>sw:3</td>
<td>sw:enemy</td>
<td>sw:2</td>
</tr>
<tr>
<td>sw:3</td>
<td>sw:enemy</td>
<td>sw:4</td>
</tr>
<tr>
<td>sw:4</td>
<td>sw:enemy</td>
<td>sw:1</td>
</tr>
<tr>
<td>sw:1</td>
<td>sw:father</td>
<td>sw:3</td>
</tr>
<tr>
<td>sw:2</td>
<td>sw:father</td>
<td>sw:3</td>
</tr>
<tr>
<td>sw:1</td>
<td>sw:lightsaber_color</td>
<td>green</td>
</tr>
<tr>
<td>sw:3</td>
<td>sw:lightsaber_color</td>
<td>red</td>
</tr>
<tr>
<td>sw:4</td>
<td>sw:ship</td>
<td>Millenium Falcon</td>
</tr>
</tbody>
</table>
<p>To merge these two tables, we simple concatenate them.
It couldn't be simpler.</p>
<p>Wait, this looks kinda familiar...</p>
<h2 id="rdf">RDF<a class="headerlink" href="#rdf" title="Permanent link">&para;</a></h2>
<p>These tables are pretty much in RDF format.
You just have to squint a little!</p>
<ul>
<li>sw_id == subject</li>
<li>property == predicate</li>
<li>value == object</li>
</ul>
<p>Each row of the table is a subject-predicate-object triple.
Our subjects, predicates, and some objects are URLs.
We also have some literal objects.
We could turn this table directly into Turtle format
with a little SQL magic
(basically just concatenating strings):</p>
<pre><code class="language-sql">SELECT &quot;@prefix sw: &lt;http://example.com/sw_&gt; .&quot;
UNION ALL
SELECT &quot;&quot;
UNION ALL
SELECT 
   sw_id
|| &quot; &quot;
|| property
|| &quot; &quot;
|| IF(
     INSTR(value, &quot;:&quot;),
     value,                -- CURIE
     &quot;&quot;&quot;&quot; || value || &quot;&quot;&quot;&quot; -- literal
   )
|| &quot; .&quot;
FROM triple_table;
</code></pre>
<p>The first few lines will look like this:</p>
<pre><code class="language-ttl">@prefix sw: &lt;http://example.com/sw_&gt; .

sw:1 sw:first_name &quot;Luke&quot; .
sw:2 sw:first_name &quot;Leia&quot; .
sw:3 sw:first_name &quot;Darth&quot; .
sw:4 sw:first_name &quot;Han&quot; .
</code></pre>
<p>Two things we're missing from RDF are
language tagged literals and typed literals.
We also haven't used any blank nodes in our triple table.
These are easy enough to add.</p>
<p>The biggest thing that's different about RDF
is that it uses the "open-world assumption",
so something may be true even though
we don't have a triple asserting that it's true.
The open-world assumption is a better fit
than the closed-world assumption
when we're integrating data on the Web.</p>
<h2 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">&para;</a></h2>
<p>Tables are great!
We use them all the time,
they're strong and rigid,
and we're comfortable with them.</p>
<p>RDF, on the other hand, looks strange at first.
For most common data processing,
RDF is <em>too</em> flexible.
But sometimes flexiblity is the most important thing.</p>
<p>The greatest strength of tables is their rigid structure,
but that's also their greatest weakness.
We saw a number of problems with tables,
and how they could be overcome
by breaking tables apart into smaller tables,
until we got down to the most basic pattern:
subject-predicate-object.
Step by step, we were pushed toward RDF.</p>
<p>Merging tables is particularly painful.
When working with data on the Web,
merging is one of the most common and important operations,
and so it makes sense to use RDF for these tasks.
If self-joins with SQL is the worst problem for EAV tables,
then SPARQL solves it.</p>
<p>These examples show that it's not really very hard
to convert tables to triples.
And once you've seen SPARQL, the RDF query language,
you've seen one good way to convert triples to tables:
SPARQL SELECT results are just tables!</p>
<p>Since it's straightforward to convert
tables to triples and back again,
make sure to use the right tool for the right job.
When you need to merge heterogeneous data, reach for triples.
For most other data processing tasks, use tables.
They're great!</p>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
